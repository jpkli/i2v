<!DOCTYPE html>
<html>
    <head>
        <title>i2v Test</title>
        <!-- data-main attribute tells require.js to load
             scripts/main.js after require.js loads. -->

    </head>
    <body>
        <h1>i2v Test</h1>
        <div id="i2vCanvas">

        </div>

        <script src="require.js"></script>
        <script>
        require([
            "p4/io/ajax",
            "p4/io/parser",
            "p4/cquery/ctypes",
            "p4/cquery/cstore",
            "i2v/webgl/webgl",
            "p4/core/datastruct",
            "p4/core/pipeline",
            "p4/core/arrays"
        ],
        function(
            ajax,
            parser,
            ctypes,
            CStore,
            WebGL,
            dataStruct,
            pipeline,
            arrays
        ){
            console.log(ajax);
            ajax.getAll([
                 {url: "randomData.csv", dataType: "text"},
                 {url: "/metadata", dataType: "json"},
                 {url: "/data", dataType: "arraybuffer"}
            ]).then(function(response){
                var text = response[0],
                    metadata = response[1],
                    binaryData = response[2];
                console.log(metadata);
                // console.log(binaryData);
                var types = metadata.types,
                    size = metadata.size,
                    offset = 0;

                var db = CStore({
                    size: size,
                    struct: [
                        {name: "rank", type: "int"},
                        {name: "timestamp", type: "float"},
                        {name: "numeric1", type: "int"},
                        {name: "numeric2", type: "int"},
                        {name: "categorical1", type: "string"},
                        {name: "numeric3", type: "int"}
                    ],
                });

                // db.addRows(csv);
                metadata.keys.forEach(function(k, i){
                    var data = new ctypes[types[i]](binaryData.slice(offset, offset+size*ctypes[types[i]].BYTES_PER_ELEMENT));
                    offset += size * ctypes[types[i]].BYTES_PER_ELEMENT;

                    db.addColumns(data, k);
                });
                //
                console.log(db.data());
                var csv = parser(text, ',');
                var terminals = dataStruct({
                    array: csv,
                    header: metadata.keys,
                    types: metadata.types,
                    skip: 0
                }).objectArray();

                // console.log(terminals);
                // db.filter({timestamp: 1000});

                console.log(db.info());

                var data = db.data(),
                    metadata = db.metadata();

                var webgl = WebGL({
                    container: "i2vCanvas",
                    height: 50,
                    width: 1200,
                    // margin: padding
                });

                //calculate the size of the texture (texture size must be power of 2)
                var attributes = ["numeric1", "numeric2", "categorical1", "numeric3"],
                    numSeries = metadata.stats["rank"].max+1,
                    numTimeSteps = metadata.stats["timestamp"].max / metadata.stats["timestamp"].min,
                    texWidth = Math.pow(2, Math.ceil(Math.log2(numTimeSteps))),
                    texHeight = Math.pow(2, Math.ceil(Math.log2(numSeries)));

                // var vArray = new Float32Array(data.rows*2);
                // for(var ii = 0; ii<data.rows; ii++){
                //     vArray[ii*2] = data.get("timestamp")[ii];
                //     vArray[ii*2+1] = data.get("rank")[ii];
                // }

                console.log(texWidth, texHeight, numTimeSteps, numSeries);

                var posXdata= data.get("timestamp");
                //
                //setup all attributes, uniform, texture, varying needed by all the shaders
                webgl.uniform("xDomain", "vec2", [metadata.stats["timestamp"].min, metadata.stats["timestamp"].max])
                    .uniform("yDomain", "vec2", [metadata.stats["rank"].min, metadata.stats["rank"].max])
                    .uniform("u_color", "vec4", [0.25, 0.545, 0.667, 1.0])
                    .uniform("u_tw", "float", metadata.stats["timestamp"].min*texWidth)
                    .uniform("u_th", "float", texHeight)
                    // .attribute("vec2", "pos", vArray )
                    .framebuffer("test", "float", 1024, 1)
                    .framebuffer("test2", "float", 8192, 8192)
                    // .attribute("posX", "float", new Float32Array(data.get("timestamp")))
                    // .attribute("posY", "float", new Float32Array(data.get("rank")))
                    .attribute("posX", "float", new Float32Array(arrays.seq(metadata.stats["timestamp"].min, metadata.stats["timestamp"].max, metadata.stats["timestamp"].min)))
                    .attribute("posY", "float",  new Float32Array(arrays.seq(0, metadata.stats["rank"].max, 1)))
                    .varying("v_sum", "vec4");
                    // .texture("sampler2D", "ttext1", data.get("timestamp"), [numSeries * numTimeSteps]);

                    // webgl.attribute.posY = new Float32Array(data.get("data_size"));
                    // webgl.attribute.posX = new Float32Array(data.get("timestamp"));



                var start = new Date();
                var result =
                pipeline()
                // .derive({
                //     groupID: "Math.floor(@rank / 10)"
                // })
                // .match({
                //     // rank: 200,
                //     timestamp: {$inRange: [1000, 25000]}
                // })
                .group({
                    $by: "rank",
                    count: "$count",
                    numeric1: "$avg",
                    numeric2: "$sum",
                    numeric3: "$sum"
                })
                .sort({
                    data_size: 1
                })
                (terminals);

                console.log(result);
                console.log(new Date() - start);


                // gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            });
        });
        </script>
    </body>
</html>
