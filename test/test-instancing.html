<!DOCTYPE html>
<html>
    <head>
        <title>i2v Test</title>
        <!-- data-main attribute tells require.js to load
             scripts/main.js after require.js loads. -->

    </head>
    <body>
        <h1>i2v Test</h1>
        <div id="i2vCanvas">

        </div>

        <script src="require.js"></script>
        <script>
        require([
            "p4/io/ajax",
            "p4/io/parser",
            "p4/cquery/cstore",
            "i2v/webgl/webgl",
            "p4/core/datastruct",
            "p4/core/pipeline",
            "p4/core/arrays"
        ],
        function(
            ajax,
            parser,
            CStore,
            WebGL,
            dataStruct,
            pipeline,
            arrays
        ){
            console.log(ajax);
            ajax.get(
                 {url: "testData.csv", dataType: "text"}
            ).then(function(text){

                var csv = parser(text, ',');
                var db = CStore({
                    size: csv.length,
                    struct: [
                        {name: "rank", type: "int"},
                        {name: "chunks_finished", type: "int"},
                        {name: "data_size", type: "int"},
                        {name: "hops_finished", type: "float"},
                        {name: "time_spend", type: "float"},
                        {name: "busy_time", type: "float"},
                        {name: "timestamp", type: "float"}
                    ],
                });

                db.addRows(csv);

                var terminals = dataStruct({
                    array: csv,
                    header: ["rank", "chunks_finished", "data_size", "hops_finished", "time_spend", "busy_time", "timestamp"],
                    types: ["int", "int", "int", "float", "float", "float", "float"],
                    skip: 1
                }).objectArray();

                // console.log(terminals);

                // db.filter({timestamp: 1000});

                // console.log(db.info());

                var data = db.data(),
                    metadata = db.metadata();

                var webgl = WebGL({
                    container: "i2vCanvas",
                    height: 300,
                    width: 1200,
                    // margin: padding
                });

                //
                //calculate the size of the texture (texture size must be power of 2)
                var attributes = ["data_size", "busy_time", "time_spend", "hops_finished"],
                    numSeries = metadata.stats["rank"].max+1,
                    numTimeSteps = metadata.stats["timestamp"].max / metadata.stats["timestamp"].min,
                    texWidth = Math.pow(2, Math.ceil(Math.log2(numTimeSteps))),
                    texHeight = Math.pow(2, Math.ceil(Math.log2(numSeries)));

                var vArray = new Float32Array(data.rows*2);
                for(var ii = 0; ii<data.rows; ii++){
                    vArray[ii*2] = data.get("timestamp")[ii];
                    vArray[ii*2+1] = data.get("rank")[ii];
                }

                console.log(texWidth, texHeight, numTimeSteps, numSeries);

                var posXdata= data.get("timestamp");
                //
                //setup all attributes, uniform, texture, varying needed by all the shaders
                webgl.uniform("xDomain","vec2", [metadata.stats["timestamp"].min, metadata.stats["timestamp"].max])
                    .uniform("yDomain","vec2", [metadata.stats["rank"].min, metadata.stats["rank"].max])
                    .uniform( "domain","vec2", [metadata.stats["time_spend"].min, metadata.stats["time_spend"].max])
                    .uniform( "u_color", "vec4", [0.25, 0.545, 0.667, 1.0])
                    .uniform("u_tw", "float", metadata.stats["timestamp"].min*texWidth)
                    .uniform("u_th", "float", texHeight)
                    // .attribute("vec2", "pos", vArray )
                    .attribute("posX", "float", new Float32Array(arrays.seq(metadata.stats["timestamp"].min, metadata.stats["timestamp"].max, metadata.stats["timestamp"].min)))
                    .attribute("posY", "float",  new Float32Array(arrays.seq(0, metadata.stats["rank"].max, 1)))
                    .varying("v_sum", "float");
                    // .texture("sampler2D", "ttext1", data.get("timestamp"), [numSeries * numTimeSteps]);


                attributes.forEach(function(attr){
                    webgl.texture(attr, "float", new Float32Array(data.get(attr)), [numTimeSteps, numSeries]);
                });


                function mainVert(){
                    $float(ts, rank, y);
                    ts = (posX - xDomain.x) / (xDomain.y - xDomain.x) * 2.0 - 1.0;
                    rank = (posY - yDomain.x) / (yDomain.y - yDomain.x)  * 2.0 - 1.0;
                    y = (texture2D(time_spend, vec2(ts, rank)).a - domain.x) / (domain.y - domain.x) * 2.0 - 1.0;
                    gl_Position = vec4(ts, y, 0.0, 1.0);
                }

                function mainFrag() {
                    gl_FragColor = u_color;
                    // gl_FragColor = vec4(1.0,1.0,1.0,10.5);
                }

                var vs = webgl.shader()
                    .vertex()
                    .require(['xDomain', "yDomain", "domain",  "posX", "posY", "time_spend"])
                    .function("void", "main", mainVert)
                    .init();
                //
                var fs = webgl.shader().fragment().require(["u_color", "v_sum"]).function("void", "main", mainFrag).init();

                var gl = webgl.program([vs, fs]);

                gl.clearColor( 1.0, 1.0, 1.0, 1.0 );
                gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );


                // gl.drawArrays(gl.POINTS, 0, numTimeSteps*numSeries);

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                // var start = new Date();
                // for(var ii = 0; ii < data.rows; ii += numTimeSteps){
                //      gl.drawArrays(gl.LINE_STRIP, 0, numTimeSteps);
                // }


                var ext = gl.getExtension("ANGLE_instanced_arrays");
                console.log(ext);
                // ext.vertexAttribDivisorANGLE(webgl.attribute.posX.location, 0);
                ext.vertexAttribDivisorANGLE(webgl.attribute.posY.location, 2);
                ext.drawArraysInstancedANGLE(gl.LINE_STRIP, 0, numTimeSteps, numSeries*2);



            });
        });
        </script>
    </body>
</html>
